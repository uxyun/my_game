<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>避けるゲーム（レスポンシブ対応）</title>
<style>
  html, body {
    margin:0; padding:0; height:100%;
    background:#222;
    color:#fff;
    font-family:sans-serif;
    user-select:none;
    -webkit-user-select:none;
    overflow:hidden;
  }
  #gameArea {
    position: relative;
    width: 100vw;
    height: calc(100vh - 100px);
    max-width: 480px;
    margin: 0 auto;
    background: #000;
    overflow: hidden;
    touch-action: none;
  }
  #score {
    position: absolute;
    top: 8px; left: 12px;
    font-size: 20px;
    font-weight: bold;
    z-index: 10;
  }
  #message {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: 28px;
    color: #0f0;
    display: none;
    z-index: 10;
    text-align: center;
    width: 90%;
  }
  /* プレイヤー画像 */
  #player {
    position: absolute;
    width: 40px; height: 40px;
    border-radius: 6px;
    background-image: url('player.png');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center center;
    image-rendering: -webkit-optimize-contrast;
  }
  /* 方向ボタンエリア */
  #controlArea {
    width: 100vw;
    max-width: 480px;
    height: 100px;
    margin: 0 auto;
    background: #111;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
    user-select: none;
    -webkit-user-select: none;
  }
  button.dirBtn {
    width: 50px; height: 50px;
    font-size: 24px;
    font-weight: bold;
    color: #fff;
    background: #444;
    border: none;
    border-radius: 8px;
    user-select: none;
    touch-action: manipulation;
  }
  button.dirBtn:active {
    background: #0af;
  }
</style>
</head>
<body>

<div id="gameArea">
  <div id="score">Score: 0.0s</div>
  <div id="message">画面の方向ボタンで操作、タップでスタート</div>
  <div id="player"></div>
  <canvas id="enemyCanvas" style="position:absolute; top:0; left:0; pointer-events:none;"></canvas>
</div>

<div id="controlArea">
  <button class="dirBtn" id="upBtn">↑</button>
  <button class="dirBtn" id="leftBtn">←</button>
  <button class="dirBtn" id="downBtn">↓</button>
  <button class="dirBtn" id="rightBtn">→</button>
</div>

<audio id="bgm" src="bgm.mp3" loop></audio>

<script>
(() => {
  const gameArea = document.getElementById('gameArea');
  const player = document.getElementById('player');
  const scoreDisplay = document.getElementById('score');
  const message = document.getElementById('message');
  const canvas = document.getElementById('enemyCanvas');
  const ctx = canvas.getContext('2d');
  const bgm = document.getElementById('bgm');

  const playerSize = 40;
  const moveSpeed = 8;
  let gameWidth, gameHeight;
  let playerX, playerY;
  let enemies = [];
  const enemySpawnInterval = 1200;
  let lastEnemySpawn = 0;
  let startTime = 0;
  let score = 0;
  let gameRunning = false;
  const keyState = {up:false, down:false, left:false, right:false};
  const enemySpeed = 3;

  // canvasをgameAreaサイズに合わせる
  function resizeCanvas() {
    gameWidth = gameArea.clientWidth;
    gameHeight = gameArea.clientHeight;
    canvas.width = gameWidth;
    canvas.height = gameHeight;
  }

  function resetPlayer() {
    playerX = (gameWidth - playerSize) / 2;
    playerY = (gameHeight - playerSize) / 2;
    updatePlayerPos();
  }
  function updatePlayerPos() {
    player.style.left = playerX + 'px';
    player.style.top = playerY + 'px';
  }

  function spawnEnemy() {
    const side = Math.floor(Math.random()*4);
    let ex, ey;
    switch(side) {
      case 0: ex = Math.random()*gameWidth; ey = -20; break;
      case 1: ex = gameWidth + 20; ey = Math.random()*gameHeight; break;
      case 2: ex = Math.random()*gameWidth; ey = gameHeight + 20; break;
      case 3: ex = -20; ey = Math.random()*gameHeight; break;
    }
    const px = playerX + playerSize/2;
    const py = playerY + playerSize/2;
    const dx = px - ex;
    const dy = py - ey;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const vx = (dx / dist) * enemySpeed;
    const vy = (dy / dist) * enemySpeed;
    enemies.push({x:ex, y:ey, vx, vy, radius:4});
  }

  function checkCollision(cx, cy, radius, rx, ry, rw, rh) {
    const closestX = Math.max(rx, Math.min(cx, rx+rw));
    const closestY = Math.max(ry, Math.min(cy, ry+rh));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx*dx + dy*dy) < (radius*radius);
  }

  function updateEnemies() {
    ctx.clearRect(0, 0, gameWidth, gameHeight);
    const px = playerX + playerSize/2;
    const py = playerY + playerSize/2;
    for(let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      e.x += e.vx;
      e.y += e.vy;
      if(checkCollision(e.x, e.y, e.radius, playerX, playerY, playerSize, playerSize)) {
        endGame();
        return;
      }
      if(e.x < -10 || e.x > gameWidth + 10 || e.y < -10 || e.y > gameHeight + 10) {
        enemies.splice(i, 1);
        continue;
      }
      ctx.beginPath();
      ctx.fillStyle = '#f33';
      ctx.shadowColor = '#f33';
      ctx.shadowBlur = 6;
      ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function movePlayer() {
    if(keyState.up) playerY -= moveSpeed;
    if(keyState.down) playerY += moveSpeed;
    if(keyState.left) playerX -= moveSpeed;
    if(keyState.right) playerX += moveSpeed;

    if(playerX < 0) playerX = 0;
    if(playerY < 0) playerY = 0;
    if(playerX > gameWidth - playerSize) playerX = gameWidth - playerSize;
    if(playerY > gameHeight - playerSize) playerY = gameHeight - playerSize;

    updatePlayerPos();
  }

  function updateScore() {
    const now = performance.now();
    score = ((now - startTime) / 1000).toFixed(1);
    scoreDisplay.textContent = 'Score: ' + score + 's';
  }

  function gameLoop() {
    if(!gameRunning) return;
    movePlayer();
    updateEnemies();
    updateScore();
    const now = performance.now();
    if(now - lastEnemySpawn > enemySpawnInterval) {
      spawnEnemy();
      lastEnemySpawn = now;
    }
    requestAnimationFrame(gameLoop);
  }

  function startGame() {
    if(gameRunning) return;
    message.style.display = 'none';
    enemies = [];
    lastEnemySpawn = 0;
    startTime = performance.now();
    score = 0;
    gameRunning = true;
    resetPlayer();
    bgm.currentTime = 0;
    bgm.play().catch(() => {
      console.log('BGM再生にユーザー操作が必要です');
    });
    requestAnimationFrame(gameLoop);
  }

  function endGame() {
    gameRunning = false;
    message.textContent = `ゲームオーバー！スコア: ${score}s 画面タップで再スタート`;
    message.style.display = 'block';
    enemies = [];
    ctx.clearRect(0, 0, gameWidth, gameHeight);
    bgm.pause();
  }

  function setupButtons() {
    const map = {
      upBtn: 'up',
      downBtn: 'down',
      leftBtn: 'left',
      rightBtn: 'right',
    };
    Object.entries(map).forEach(([id, key]) => {
      const btn = document.getElementById(id);
      btn.addEventListener('touchstart', e => {
        e.preventDefault();
        keyState[key] = true;
      }, {passive:false});
      btn.addEventListener('touchend', e => {
        e.preventDefault();
        keyState[key] = false;
      }, {passive:false});
      btn.addEventListener('mousedown', e => {
        e.preventDefault();
        keyState[key] = true;
      });
      btn.addEventListener('mouseup', e => {
        e.preventDefault();
        keyState[key] = false;
      });
      btn.addEventListener('mouseleave', e => {
        keyState[key] = false;
      });
    });
  }

  gameArea.addEventListener('click', () => {
    if(!gameRunning) startGame();
  });
  gameArea.addEventListener('touchstart', () => {
    if(!gameRunning) startGame();
  });

  window.addEventListener('resize', () => {
    resizeCanvas();
    resetPlayer();
  });

  resizeCanvas();
  resetPlayer();
  setupButtons();
  message.style.display = 'block';

})();
</script>

</body>
</html>
