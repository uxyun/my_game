
<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>BlizzardK Shooting</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <style>
    body { margin: 0; background: #222; color: white; text-align: center; }
    #gameContainer { margin: auto; }
    canvas { touch-action: none; }
  </style>
</head>
<body>
  <h1>Blizzard-K</h1>
  <p>å·¦å³ã‚¿ãƒƒãƒ—ã§ç§»å‹•ã€è‡ªå‹•ã§å¼¾ã‚’ç™ºå°„ã€‚30ç§’ã§ã‚¹ã‚³ã‚¢å‹è² ï¼</p>
  <div id="gameContainer"></div>

  <script>
    const config = {
      type: Phaser.AUTO,
      width: 400,
      height: 600,
      parent: 'gameContainer',
      physics: {
        default: 'arcade',
        arcade: { debug: false }
      },
      scene: { preload, create, update }
    };

    let game = new Phaser.Game(config);
    let player, bullets, enemies, cursors;
    let score = 0;
    let scoreText, timerText;
    let timeLeft = 30;
    let bgm;

    const enemyChars = ['B', 'l', 'i', 'z', 'z', 'a', 'r', 'd', 'K'];

    function preload() {
      this.load.image('playerFace', 'player.png');
      this.load.image('bullet', 'https://labs.phaser.io/assets/sprites/bullet.png');
      this.load.audio('bgm', 'bgm.mp3');
    }

    function create() {
      player = this.physics.add.sprite(200, 550, 'playerFace').setScale(0.3);
      player.setCollideWorldBounds(true);

      bullets = this.physics.add.group({ defaultKey: 'bullet', maxSize: 10 });
      enemies = this.add.group();
      cursors = this.input.keyboard.createCursorKeys();

      scoreText = this.add.text(10, 10, 'Score: 0', { fontSize: '20px', fill: '#fff' });
      timerText = this.add.text(280, 10, 'Time: 30', { fontSize: '20px', fill: '#fff' });

      this.time.addEvent({ delay: 1000, callback: () => {
        timeLeft--;
        timerText.setText('Time: ' + timeLeft);
        if (timeLeft <= 0) endGame(this);
      }, loop: true });

      this.time.addEvent({ delay: 1000, callback: spawnEnemy, callbackScope: this, loop: true });
      this.time.addEvent({ delay: 500, callback: () => shootBullet(this), loop: true });

      this.physics.add.overlap(bullets, enemies, hitEnemy, null, this);

      bgm = this.sound.add('bgm', { loop: true, volume: 0.5 });
      bgm.play();

      this.input.on('pointerdown', (pointer) => {
        if (pointer.x < 200) {
          player.setVelocityX(-200);
        } else {
          player.setVelocityX(200);
        }
      });

      this.input.on('pointerup', () => {
        player.setVelocityX(0);
      });
    }

    function update() {
      if (cursors.left.isDown) {
        player.setVelocityX(-200);
      } else if (cursors.right.isDown) {
        player.setVelocityX(200);
      } else {
        player.setVelocityX(0);
      }

      bullets.children.each(b => {
        if (b.active && b.y < 0) b.setActive(false).setVisible(false).body.enable = false;
      });

      enemies.children.each(e => {
        if (e.active && e.y > 650) e.destroy();
      });
    }

    function spawnEnemy() {
      let x = Phaser.Math.Between(20, 360);
      let char = Phaser.Utils.Array.GetRandom(enemyChars);

      let enemy = this.add.text(x, 0, char, {
        fontSize: '32px',
        fill: (char === 'K') ? '#ff4444' : '#ffffff'
      });
      this.physics.add.existing(enemy);
      enemy.body.setVelocityY(100);
      enemy.char = char;
      enemy.setData('isEnemy', true);

      enemies.add(enemy);
    }

    function shootBullet(scene) {
      let bullet = bullets.get(player.x, player.y - 20);
      if (bullet) {
        bullet.setActive(true).setVisible(true).body.enable = true;
        bullet.setVelocityY(-300);
      }
    }

    function hitEnemy(bullet, enemy) {
      bullet.setActive(false).setVisible(false).body.enable = false;
      if (enemy.getData('isEnemy')) {
        enemy.destroy();
        score += (enemy.char === 'K') ? 100 : 10;
        scoreText.setText('Score: ' + score);
      }
    }

    function endGame(scene) {
      scene.physics.pause();
      bgm.stop();
      const playerName = prompt('ã‚²ãƒ¼ãƒ çµ‚äº†ï¼åå‰ã‚’å…¥åŠ›ã—ã¦ã­ï¼š', 'Player');
      if (playerName) saveScore(playerName, score);
      showRanking(scene);
    }

    function saveScore(name, score) {
      let records = JSON.parse(localStorage.getItem('shooting_ranking')) || [];
      records.push({ name, score });
      records.sort((a, b) => b.score - a.score);
      records = records.slice(0, 5);
      localStorage.setItem('shooting_ranking', JSON.stringify(records));
    }

    function showRanking(scene) {
      let records = JSON.parse(localStorage.getItem('shooting_ranking')) || [];
      let y = 200;
      scene.add.text(100, y - 40, 'ğŸ† ãƒ©ãƒ³ã‚­ãƒ³ã‚° ğŸ†', { fontSize: '24px', fill: '#ff0' });
      records.forEach((entry, i) => {
        scene.add.text(100, y + i * 30, `${i + 1}. ${entry.name} - ${entry.score}ç‚¹`, {
          fontSize: '20px',
          fill: '#fff'
        });
      });
      scene.add.text(100, y + records.length * 30 + 40, 'ãƒªãƒ­ãƒ¼ãƒ‰ã§å†ãƒ—ãƒ¬ã‚¤', {
        fontSize: '16px',
        fill: '#aaa'
      });
    }
  </script>
</body>
</html>
